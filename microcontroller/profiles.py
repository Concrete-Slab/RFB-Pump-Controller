from typing import Any, Union
from serial.tools.list_ports import comports
from pathlib import Path
import os.path
from dataclasses import dataclass, asdict
from support_classes import open_local, get_path
import json
from .codegen import PinDefs, maybe_generate_code, generate_code

class InvalidProfileException(BaseException):
    pass

_SUPPORTED_EXTENSIONS = ["cpp",".ino"]

_PROFILES_PATH = "microcontroller_profiles.json"

@dataclass
class MicrocontrollerProfile:
    profile_name: str
    serial_port: str
    num_pumps: int
    debug_only: bool


    @staticmethod
    def from_json(json_list: list[dict[str,Any]]) -> list["MicrocontrollerProfile"]:
        default_microcontroller = MicrocontrollerProfile("","",1,False)
        out = [default_microcontroller]*len(json_list)
        for i,microcontroller_dict in enumerate(json_list):
            if "pin_assignments" in microcontroller_dict.keys():
                microcontroller_dict.pop("num_pumps")
                microcontroller_dict["pin_assignments"] = [PinDefs(**pd) for pd in microcontroller_dict["pin_assignments"]]
                out[i] = AutoGeneratedProfile(**microcontroller_dict)
            else:
                out[i] = MicrocontrollerProfile(**microcontroller_dict)
        return out
    
    def as_dict(self):
        return asdict(self)
    
    @classmethod
    def from_dict(cls,dict_in: dict[str,Any]):
        return MicrocontrollerProfile(**dict_in)
    
    @staticmethod
    def to_json(profiles: list["MicrocontrollerProfile"]) -> list[dict[str,Any]]:
        return [profile.as_dict() for profile in profiles]
    
    def validate(self):
        if self.num_pumps<1:
            raise InvalidProfileException("Number of pumps must be positive integer")
        # all_serial_ports = comports()
        # if self.serial_port not in [port.device for port in all_serial_ports]:
        #     raise InvalidProfileException(f"Serial port not found: {self.serial_port}")

@dataclass(init=False)
class AutoGeneratedProfile(MicrocontrollerProfile):
    pin_assignments: list[PinDefs]
    code_location: Path|None = None
    device_name: str | None = None

    def __init__(self, profile_name: str, serial_port: str, debug_only: bool, pin_assignments: list[PinDefs], code_location: Path|str|None = None, device_name: str|None = None):
        super().__init__(profile_name,serial_port,len(pin_assignments),debug_only)
        self.device_name = device_name
        if isinstance(code_location,str):
            code_location = Path(code_location)
        self.code_location = code_location
        self.pin_assignments = pin_assignments

    def validate(self):
        # if not os.path.exists(self.code_location):
        #     raise InvalidProfileException(f"Microcontroller code filepath does not exist: {self.code_location.as_posix() if isinstance(self.code_location,Path) else self.code_location}")
        # file_type = self.code_location.as_posix().split(".")[-1]
        # if file_type not in _SUPPORTED_EXTENSIONS:
        #     raise InvalidProfileException(f"File extension .{file_type} is not supported")
        return super().validate()
    
    def as_dict(self) -> dict[str,Any]:
        out = asdict(self)
        out["code_location"] = self.code_location.as_posix() if self.code_location else None
        return out
    
    @classmethod
    def from_dict(cls, dict_in: dict[str,Any]):
        if len(dict_in["pin_assignments"])<1:
            raise ValueError("Must provide more than 1 pin assignment for auto profile")
        if "num_pumps" in dict_in.keys():
            dict_in.pop("num_pumps")
        pin_assignments_raw: list[dict[str,int]] = dict_in["pin_assignments"]
        dict_in["pin_assignments"] = [PinDefs(**pindef) for pindef in pin_assignments_raw if not isinstance(pindef,PinDefs)]
        return AutoGeneratedProfile(**dict_in)
    
    def generate(self, compare_to: Union["AutoGeneratedProfile",list[PinDefs],None] = None):
        if isinstance(compare_to,AutoGeneratedProfile):
            compare_to = compare_to.pin_assignments
        filename = self.profile_name + "_(codegen).cpp"
        return maybe_generate_code(filename,self.pin_assignments, compare_to=compare_to)
    
    # def upload(self):
    #     arduino = pdc.Arduino()
    #     arduino.upload


def save_profile(profile: MicrocontrollerProfile):
    all_profiles = read_profiles(debug=True)
    new_profile = True
    i=0
    while new_profile and i<len(all_profiles):
        if all_profiles[i].profile_name == profile.profile_name:
            all_profiles[i] = profile
            new_profile = False
        i = i+1
    if new_profile:
        all_profiles.append(profile)
    
    profile.validate()
    json_obj = MicrocontrollerProfile.to_json(all_profiles)

    with open_local(_PROFILES_PATH,"w") as f:
        json.dump(json_obj,f)

def profile_names(debug=False) -> list[str]:
    try:
        with open_local(_PROFILES_PATH,"r") as f:
            profiles_json: list[dict[str,Any]] = json.load(f)
        profile_names = [p["profile_name"] for p in profiles_json]
        return [p for i,p in enumerate(profile_names) if (debug or not profiles_json[i]["debug_only"])]
    except FileNotFoundError:
        return []


def read_profiles(debug=False) -> list[MicrocontrollerProfile]:
    try:
        with open_local(_PROFILES_PATH,"r") as f:
            profiles_json: list[dict[str,Any]] = json.load(f)
            profiles = MicrocontrollerProfile.from_json(profiles_json)
            return [p for p in profiles if (debug or not p.debug_only)]
    except FileNotFoundError:
        return []
    
def read_profile(profile_name: str, debug=False):
    all_profiles = read_profiles(debug=debug)
    i = 0
    while i<len(all_profiles):
        if all_profiles[i].profile_name == profile_name:
            return all_profiles[i]
        i+=1
    raise InvalidProfileException(f"Profile {profile_name} could not be found.")

def overwrite_profiles(profiles: list[MicrocontrollerProfile]):
    for p in profiles:
        p.validate()
    json_obj = MicrocontrollerProfile.to_json(profiles)
    with open_local(_PROFILES_PATH,"w") as f:
        json.dump(json_obj,f)
    
    


